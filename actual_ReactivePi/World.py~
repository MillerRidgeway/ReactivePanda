# World.py

# Done

# This creates top level GUI signals and the world and cam objects.


from Time import *
from Signal import *
from Numerics import *
from Types import *
from Switchers import *
from copy import copy
from Handle import *
from FRP import tag, hold, typedVar, timeIs, localTimeIs
import sys,os
from random import *
from g import* # Global names



class World(Handle):
# This initialization code sets up global variables in g as well as the
# world object internals
  def __init__(self):
     g.world = self
     Handle.__init__(self, isWorld = True, name = "World")
     # Signals native to the world object - note that all have defaults
     self.__dict__['color']   = newSignalRefd(self, 'color', ColorType, gray)

  def refresh(self):
    Handle.refresh(self)
    # Check all world-level events
    for w in g.reactEvents:
        w.check()
    c = self.color.now()
    base.setBackgroundColor(c.r, c.g, c.b)

  def kill(self):
       print "World object received a kill signal"
       exit()

def initializeGlobals():
     g.eventSignals = {}
     g.newEvents = {}
     g.events = {}
     g.reactEvents = []
     g.newModels = []
     g.tracking = False
     g.tccontext = None
     g.world = world



  # These methods handle signals from the GUI
  # Cache keypress events so there's no duplication of key events - not
  # sure this is useful but it can't hurt.  Probably not a good idea to
  # have multiple accepts for the same event.
  
def getEventSignal(ename, val):
        if g.eventSignals.has_key(ename):
            return tag(val, g.eventSignals[ename])
        e = EventMonitor(ename)
        g.eventSignals[ename] = e
        g.directObj.accept(ename, lambda: postEvent(ename))
        return tag(val, e)

# This saves event occurances in g.newEvents
def postEvent(ename, val = True):
        g.newEvents[ename] = val

# Initialize the environment
initTime()     #  Sets current time to 0

# Exported vocabulary
world = World()
initializeGlobals()
# The underlying Panda3D system uses the name "camera" so we'll use "cam" instead
# Bring the GUI behaviors / events to the user namespace

def react(event, handler):
    world.react(event, handler)

def react1(event, handler):
    world.react1(event, handler)

def when(event, handler):
    world.when(event, handler)

def when1(event, handler):
    world.when1(event, handler)

allKeyNames = ["escape", "f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12", 
               "backspace", "insert", "home", "page_up", "num_lock",
               "tab",  "delete", "end", "page_down",
               "enter", "arrow_left", "arrow_up", "arrow_down", "arrow_right", 
               "space"]
def checkValidKey(s):
    if s == " ":
        return "space"
    if s == "left-arrow":
        return "arrow_left"
    if s == "right-arrow":
        return "arrow_right"
    if s == "up-arrow":
        return "arrow_up"
    if s == "down-arrow":
        return "arrow_down"
    if type(s) is type("s"):
        if len(s) == 1 or s in allKeyNames:
            return s
    badKeyName(s)

# Clear out the world.  This doesn't reset the global time or camera position.
def resetWorld():
    for m in g.models:
        if m is not world:
            m.exit()
    world.d.switches = []
    world.d.newswitches = []

# This is used in the launch function in the Physics module.  You can change this if you want another
# gravitational constant / direction.  The 5 assumes that a unit is approx 2 meters - that is, the effects of
# gravity will look natural for objects that would be 2 meters high in the real world (this is a good approx for the panda!)

def atTime(n, r):
    react(timeIs(n), lambda m,v: r())

def atLocalTime(n, r):
    react(localTimeIs(n), lambda m, v: r())

